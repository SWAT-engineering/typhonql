
# TyphonQL: an Evolving User Manual

## Introduction

TyphonQL is a query language and data-manipulation language (DML) to access polystores (federations of 
different kinds of database back-ends, relational, document, key-value etc.) while at the same time
abstracting as much as possible from how the data is actually stored.

Executing TyphonQL queries is parameterized by a TyphonML model, which provides the logical data schema in the
form of an object-oriented information model. A TyphonML model declares entities with primitively-typed attributes, 
and bi-directional (many-valued) relations (which can be containment/ownership) relations. 

TyphonQL is designed to allow the query writer to think at the level of TyphonML entities as much as possible. 
With TyphonQL one does not manipulate tables, graphs, documents, or key-value pairs, but sets of objects which 
may have relations to each other, and which conform to the entity types declared in the TyphonML model. 

The present document aims to describe the TyphonQL in sufficient detail for end-users of the language. 
Thus, it is not a formal reference document, but rather a short overview, touching upon the most common and 
most quirky features in equal amount.

The next section presents an abstract overview of the language, and after we present the language using numerous examples.

*NB*: like TyphonQL itself, this manual, is work-in-progress. It describes how the designers of TyphonQL 
(Tijs van der Storm, Pablo Inostroza, Davy Landman) expect the language to work, -- there might be bugs.


## The Language

This section provides a cursory overview of the language.

### Literal expressions

TyphonQL supports the following literal (constant) expressions:

- Booleans: `true`, `false`
- Integer numbers: `123`, `-34934`
- Strings: `"this is a string value"`
- Floating point numbers: `0.123`, `3.14`, `-0.123e10`, `2324.3434e-23`
- Dates:  `$2020-03-31$`
- Date and time values:  `$2020-03-31T18:08:28.477+00:00$`
- Geographical points: `#point(23.4 343.34)`
- Polygons: `#polygon((23.4 343.34), (2.0 0.0))`;
- Null (indicating absence of a reference or value): `null`

Furthermore, TyphonQL supports syntax for dealing with objects (instances of entity types):

- Object literals (tagged with the entity type, in this case `Person`): `Person {name: "Pablo", age: 30, reviews: [#879b4559-f590-48ea-968c-ff3b69ec5363, #23275eec-4746-4f23-a854-660160cafed2]}`
- Reference values (pointers), represented as UUIDs: `#879b4559-f590-48ea-968c-ff3b69ec5363`
- Collections of pointers to objects:  `[#8bc3f0a0-5cf4-42e5-a664-0617feb2d400, #23275eec-4746-4f23-a854-660160cafed2, #879b4559-f590-48ea-968c-ff3b69ec5363]`

Object literals are used as argument to insert statements, and (lists of) references are used in 
both insert and update statements to create links/relations between objects. 
In the future we might support nesting of object literals and within-insert symbolic cross referencing
to manipulate complete object graphs all at once.      

### Other expressions

Select queries as well as update and delete statements use expressions to filter results and find objects to operate on 
respectively. For instance, a from-select query specifies a number of result expressions and conditions in the where-clause.
Update and delete find the object(s) to be update resp. deleted using similar conditions in a where-clause.

TyphonQL supports the following non-literal expressions:

- Attribute or relation access: `entity.field`
- Accessing the identity of an object: `entity.@id`
- Boolean operators: `!exp` (negation), `exp1 && exp2` (conjunction), `exp1 || exp2` (disjunction)
- Arithmetic operators: `exp1 * exp2`, `exp1 / exp2`, `exp1 + exp2`, `exp1 - exp2`
- Comparison operators: `exp1 == exp2`, `exp1 != exp1`, `exp1 > exp2`, `exp1 >= exp2`, etc.

The prefix and infix operators follow the precedence levels of Java-like languages.

To be implemented:
- member operator: `exp1 in exp2`
- textual match operator: `exp1 like exp2`

#### Geographical expressions


```
pt1 = point(1.3,2.5)
pt2 = point(3.5,4.6)
pg1 = polygon([
  [point(0,0), pt1], 
  [pt1, point(1,1)], 
  [point(1,1), pt2], 
  [pt2, point(0,0)]
])
pg2 = polygon([
  [point(3,0), pt1], 
  [pt1, point(2,2)], 
  [point(2,2), pt2], 
  [pt2, point(3,2)]
])
```

- distance in meters:
  - two points: `distance(pt1, pt2)` (better idea for a infix operator are welcome, but it looked a bit strange to me)
  - one point and closest edge of polygon: `distance(pt1, pg2)`
- containment:
  - point inside a polygon: `pt1 in pg2`
  - polygon fully inside another polygon: `pg1 in pg2`
- overlap:
  - polygon partially overlaps another polygon: `pg1 & pg2`


*note*: on mongodb backends distance is limited to the where query and only in presence of a comparision operator. 

### Queries

Queries follow the tradition of SQL queries, except that the select and from parts are swapped. 
A basic query thus has the form of "*from* bindings *select* results *where* conditions".
Bindings consist of a list of "Entity Variable" pairs, separated by comma, which introduce the scope of the query.
Results is a list of expressions (separated by commas) that will make up the final result of the query.
The where-clause is optional, but if present it consists of a list of expressions (separated by commas)
filtering the result set. 

For now, in results the only allowed expressions are `x` (an entity variable introduced in the bindings), `x.@id`, and `x.f` 
(attribute or relation access). 

### DML

The general form of the insert statement is "*insert* Entity { assignments }".
The entity is the type of the object to be inserted as defined in the TyphonML statement.
The assignments are bindings of the form "attrOrRelation: expression". 
The TyphonQL type checker will check that all assignments are correctly typed according
the TyphonML model, including multiplicity constraints. 

Update and delete statements specify the objects to work on via where-clauses.
For instance, update has the form "*update* Entity x *where* conditions *set* { assignments }".
The assignments are the same as in insert, except that for many-valued relations, they can specify
additions ("relation +: expression") and removals ("relation -: expression").

Delete has the form "*delete* Entity x *where* conditions", which will delete all entities of type Entity satisfying
the conditions in the where-clause. 

All three DML statements ensure (as much as possible) that relational integrity is preserved, 
even across database back-ends. In particular
this means:

- creating resp. breaking a relation between entities entail creating resp. breaking the inverse link as well 
(if so declared in the TyphonML model)
- deleting an object will delete all objects "owned" by it via containment relations (cascading delete).

Cascading delete of contained object is currently limited to one hop across database boundaries. 
In other words, if a sequence of containment relations alternatingly cross multiple database back-ends
the cascade is only performed for the first relation.











  


# TyphonQL by Example


```typhonML
entity Product {
	name : string[256]
	description : string[256]
	price : int
	productionDate : date
		
	reviews :-> Review."Review.product"[0..*]
}

entity Review {
	content: text
	
	product -> Product[1]
	user -> User[1]
}


entity User {
	name : string[256]
	address: string[256]
	
	biography :-> Biography[0..1]
	reviews :-> Review."Review.user"[0..*]
}

entity Biography{
	content : string[256]
	
	user -> User[1]
}

relationaldb Inventory {
	tables{ 
	  table { UserDB : User }
      table { ProductDB : Product }
	}
}

documentdb Reviews {
	collections{
	  Review : Review
	  Biography : Biography
	}
}
```

## Well-formedness of TyphonML models

- containment is uni-directional (e.g. inverses of containment cannot be containment)
- containment is not many-to-many (i.e. tree shaped)
- containment is uniquely rooted: every owned entity can be reached from a unique 
path starting from an entity that is not owned




## Realizing references 

TyphonML references support bidirectional navigation over relations between entities through inverses (AKA "opposites").
In the implementation, however, we must choose one particular direction to implement the relation. 
Technically, we could maintain bidirectional relations in both directions, but this would create a lot of redundancy
in the various back-ends, and incur a lot of administrative overhead to maintain referential integrity.

Given a TyphonML model, TyphonQL realizes the "canonical" direction of a relation. Which direction is 
canonical is determined as follows:

If a reference represents containment (ownership), the parent/owner "owns" the reference as well.
So a containment relation R between A and B will be implemented on the side of A. If A and B are both in 
the same SQL database, this results in a foreign key on B, pointing to A. If A is on SQL, but B is 
elsewhere, the reference is realized using a junction table in the database of A.

If both A and B are on MongoDB, the reference is realized by nesting B's directly below A.R.  If A is on MongoDB, 
but B is elsewhere, A will contain (an array) of ids which correspond to the identities of the outside Bs.

If a relation A-R-B is *not* containment, we need a reliable way to determine which of A or B is the "master" entity.
To avoid picking some arbitrary side of such a relation, we require the TyphonML author explicitly indicate the "master" side
of such a relation. This is done by declaring inverses/opposites only on one side of the relation; then *that* side is 
the "derived" side, and the other one the primary/canonical side which will be realized in the back-end.

Consider the following example:
```typhonML
entity A { b -> B }

entity B { a -> A."A.b" }
```

In this case B declares that a is the opposite of A.b, so it won't be implemented. The entity A does not
specify the opposite, so it is the side that will be realized. In the case A resides on SQL, it will be a junction table; 
if A is on Mongo, the cross-reference will be realized using (an array of) id-ref(s). 

As a result, the use of inverses [TODO] will be desugared to using the canonical side:
```
from A a, B b select b where b.a == a.@id
```
Is equivalent to:
```
from A a, B b select b where a.b == b.@id
```


## Querying

Mongo: expression: field op non-field or reverse, but not fields at both sides.


```
from User u, Product p, Review r select u.name, p.name
 where u.reviews == r, p.reviews == r, r.text like "bad"
```


## Manipulating Data


### Insert

Well-formedness of Insert
- no inverses, just canonical relations
- no nested documents (for now)

```
insert User { name: "John Smith", age: 30 }
```


```
insert User { name: "John Smith", age: 30, cards: [#a129feec-4b92-4ab2-9ef5-d276a7566f56] }
```

```
insert CreditCard { number: "1762376287", expires:  $2020-02-21T14:03:45.274+00:00$ }
```

The following is not allowed, because owner is an inverse.
```
insert CreditCard { 
  number: "1762376287", 
  expires:  $2020-02-21T14:03:45.274+00:00$,
  owner: #ff704edc-5d85-470b-9ed4-fb8761bbe93a
}
```


Alternative is:
```
insert CreditCard { 
  number: "1762376287", 
  expires:  $2020-02-21T14:03:45.274+00:00$
}
```

and then:
```
update User u where u.@id == #ff704edc-5d85-470b-9ed4-fb8761bbe93a
set { cards +: [#the-id-of-the-new-creditcard] }
```


Or, (better), inserting into owner directly:



### Update

Well-formedness of Update
- you cannot update @id fields
- no nested object literals



Updating simple-valued attributes

```
update User u where u.name == "John Smith" set { age: 30 }
```

Updating custom data types: TODO.

Setting a relation:

```
update Review r where r.@id == #13245f43-634f-46bf-a73d-6bd30865f5d4
  set { author: #a129feec-4b92-4ab2-9ef5-d276a7566f56 }
``` 

This is equivalent to:

```
update User u where u.@id == #a129feec-4b92-4ab2-9ef5-d276a7566f56
  set { reviews +: [#13245f43-634f-46bf-a73d-6bd30865f5d4] }
```

// is this possible? Shouldn't review already have an owner? i.e. the author?


Setting a many-valued relation:

```
update User u where u.name == "John Smith"
  set { cards: [#a129feec-4b92-4ab2-9ef5-d276a7566f56] }
``` 

Adding:

```
update User u where u.name == "John Smith"
  set { cards +: [#a129feec-4b92-4ab2-9ef5-d276a7566f56] }
``` 

Removing
```
update User u where u.name == "John Smith"
  set { cards -: [#a129feec-4b92-4ab2-9ef5-d276a7566f56] }
``` 


### Delete

- cascade to owned things, but only one hop across database boundaries.

## Placeholders


```
update User u where u.@id == ?
  set { cards +: [#a129feec-4b92-4ab2-9ef5-d276a7566f56] }
``` 

Named placeholders:

```
update User u where u.@id == ??param
  set { cards +: [#a129feec-4b92-4ab2-9ef5-d276a7566f56] }
``` 

## Miscellaneous
 

 
 



